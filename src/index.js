/**
 * CLI interface for productionist-js
 * @author Johnathan Pagnutti
 *
 * NOTE: probably should rename this and make it the compilation target for node-cli
 */

/**
 * commander is an CLI arguments parsing library for node.js.
 * @type {Object}
 */
import Program from 'commander'; //using commander for node to do argument parsing
import Productionist from './modules/productionist';
import ContentRequest from './modules/contentRequest';

//NOTE [Port] some temp vars here because commander isn't super great at non-named arguments
var contentBundleName;
var contentBundleDir;

Program
  .version('0.1.0')
  .option('--n <n>', "The number of generated outputs that are requested (default: 1)", parseInt)
  .option('--symbol <symbol>', "The name of the nonterminal symbol that will be expanded to generate n examples; passing " +
                              "an argument for this will cancel any arguments passed for 'rule', 'must_have', " +
                              "'must_not_have', and 'scoring_metric'.")
  .option('--rule <rule>', "The definition of the production rule ('[rule name] --> [rule body]') that will be " +
                          "executed to generate n examples; passing an argument for this will cancel any arguments " +
                          "passed for 'must_have', 'must_not_have', and 'scoring_metric'.")
  .option('--must_have <tags>', "Tags that must be attached to the generated output; " +
                                "tags should be formatted [tagset]:[tag],[tagset:tag],[tagset:tag]")
  .option('--must_not_have <tags>', "Tags that must *not* be attached to the generated output; " +
                                    "Tags should be formatted [tagset]:[tag],[tagset:tag],[tagset:tag]")
  .option('--scoring_metric <metric>', "A scoring metric for any other tags, indicating how desirable (or undesirable) they are currently; " +
                                      "tags should be formatted [tagset]:[tag]*[weight],[tagset:tag]*[weight],[tagset:tag]*[weight]")
  .option('--nonprobabilistic', "Whether to disengage probabilistic mode (flag argument); if probabilistic mode is not engaged, the " +
                                "highest scoring option will always be selected (yields deterministic and potentially repetitive " +
                                "behavior; if it is engaged, options will be selected probabilistically according to their scored " +
                                "utility.")
  .option('--repetition_penalty', "Whether to engage repetition-penality mode (flag argument); when repetition-penalty mode is turned " +
                                  "on, Productionist will be less likely to take paths in the grammar that were recently taken.")
  .option('--terse', "Whether to engage terse mode (flag argument); when terse mode is engaged, shorter outputs (in " +
                    "terms of number of characters) will be prioritzed.")
  .option('--test', "Whether to engage test mode (flag argument); when test mode is engaged, the system forms a random " +
                    "content request and attempts to satisfy it.")
  .option('--seed', "An integer seed for the pseudrandom number generator that Productionist uses", parseInt)
  .option('--verbosity <verb>', "How verbose Productionist's debug text should be (0=no debug text, 1=more debug text, 2=most debug text)", parseInt)

Program
  .command('* <content_bundle_name> <content_bundle_dir>')
  .description('Generate some text with productionist!  content_bundle_name is the name of the content bundle that is to be ' +
              "operated over (i.e., 'talktown' to use files generated by Reductionist that are named 'talktown.grammar', " +
              "'talktown.trie', and 'talktown.meanings'\ncontent_bundle_dir is the full filepath to the bundle of content files" +
              "generated by Reductionist.")
  .action(function(content_bundle_name, content_bundle_dir){
    contentBundleName = content_bundle_name;
    contentBundleDir = content_bundle_dir;
  });

Program.parse(process.argv);
//Set the random seed, if one was specified TODO: ahahahaaha.  You can't seed JSs rng.  OF COURSE.
if(Program.seed){
  console.log("Currently, this port does not support seeding.");
}
if(typeof Program.terse === 'undefined'){
  Program.terse = false;
}
if(typeof Program.nonprobabilistic === 'undefined'){
  Program.nonprobabilistic = false;
}
if(typeof Program.repetition_penalty === 'undefined'){
  Program.repetition_penalty = false;
}
if(typeof Program.test === 'undefined'){
  Program.test = false;
}

var productionist = new Productionist(
  contentBundleName,
  contentBundleDir,
  !Program.nonprobabilistic,
  Program.repetition_penalty,
  Program.terse,
  Program.verbosity
);

//NOTE [Port] we gotta finish the productionist object before we can start to use it.
//            This means loading in affiliated files and updating the object as each one
//            loads in.
productionist.finalizeProductionist()
  .then(productionist => {
    var outputs = [];
    if(Program.symbol){
      outputs = new Array(Program.n).map(() => productionist.furnishExampleTerminalExpansionOfNonterminalSymbol(Program.symbol));
    }else if(Program.rule){
      outputs = new Array(Program.n).map(() => productionist.furnishExampleTerminalResultOfExecutingProductionRule(Program.rule));
    }else{
      let mustHave;
      let mustNotHave;
      let scoringMetric;
      if(!Program.test){
        //build a content request by parsing the relevant command-line arguments
        mustHave = new Set();
        if(Program.must_have){
          mustHave = new Set(Program.must_have.split(','));
        }
        mustNotHave = new Set();
        if(Program.must_not_have){
          mustNotHave = new Set(Program.must_not_have.split(','));
        }
        scoringMetric = [];
        if(Program.scoring_metric){
          for(let tagAndWeight of Program.scoring_metric.split(',')){
            let pair = tagAndWeight.split('*');
            let weight = Number(pair[1]);
            scoringMetric.push([pair[0], weight]);
          }
        }
      }else{
        // form a content request that solicits a randomly selected tag
        let allTags = new Set();
        for(let s of productionist.grammar.nonterminalSymbols){
          allTags.add(s);
        }
        mustHave = new Set([...allTags][Math.floor(Math.random() * allTags.size)].tags);
        mustNotHave = new Set();
        scoringMetric = [];
      }
      let contentRequest = new ContentRequest(mustHave, mustNotHave, scoringMetric);
      if(Program.verbosity > 0){
        console.log(
          "\n-- Attempting to fulfill the following content request:\n" +
          `\n\tMust have: ${contentRequest.mustHave.size > 0 ? [...contentRequest.mustHave.values()].join(', ') : 'N/A'}` +
          `\n\tMust not have: ${contentRequest.mustNotHave.size > 0 ? [...contentRequest.mustNotHave.values()].join(', '): 'N/A'}` +
          `\n\tScoring metric: ${scoringMetric.length > 0 ? scoringMetric.map(t => t.toString()).join(', ') : 'N/A'}`
        )
      }
      outputs = new Array(Program.n).map(() => productionist.fulfillContentRequest(contentRequest));
    }

    for(let i = 0; i < outputs.length; i++){
      let output = outputs[i];
      if(Program.verbosity > 0){
        console.log("\n\n-- Successfully generated an output:");
        // Print the generated output
        console.log(`\n\t${output}`);
        // Print out all the tags attached to the generated output
        console.log("\nThe following tags are attached to this output:");
        for(let tag of output.tags){
            console.log(`\t${tag}`);
        }
        // Print the tree expression for the generated output
        console.log(
          "\n\n-- Here's a tree expression illustrating the series of expansions " +
          "that produced this output:"
        );
        console.log(`\n${output.treeExpression}`);
        // Print the tagged tree expression for the generated output
        console.log("\n\n-- Here's a tree expression that shows how the generated content got its tags:");
        console.log(`\n${output.treeExpressionWithTags}`);
        // Print the bracketed expression for the generated output
        console.log("\n\n-- Here's a bracketed expression that more economically illustrates " +
                    "the derivation of the content:");
        console.log(`\n${output.bracketedExpression}`);
        console.log('\n\n');
      }else{
        console.log(`#${i+1}`);
        console.log(`--Output--\n${output.toString()}`);
        console.log(`--Tags--\n${output.tags.join(',')}`);
        console.log(`--Bracketed Expression--\n${output.bracketedExpression}`);
        console.log(`--Tree Expression--\n${output.treeExpression}`);
        console.log(`-- Tree Expression (with tags)--\n${output.treeExpressionWithTags}`);
      }
    }
    // Lastly, save out the updated repetitions file, if applicable, for future use
    // TODO [Port] not in this port yet, due to the weirdness of where HAVE_REPETITIONS_FILE_PRESIST_ACROSS_RUNTIME_INSTANCES
    // is located.
    if (productionist.reptitionPenalityMode && false){
      return productionist.saveRepetitionPenaltiesFile(); //TODO this is not currently, but we'd return another promise here.
    }
  })
    .catch(err => console.log(err));
